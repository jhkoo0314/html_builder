<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Step2-A Editor</title>
    <style>
      :root {
        --bg: #f5f7fb;
        --panel: #ffffff;
        --line: #d8e1ef;
        --ink: #17212e;
        --muted: #5f6e82;
        --brand: #0f766e;
      }
      * { box-sizing: border-box; }
      body {
        margin: 0;
        font-family: "Segoe UI", sans-serif;
        color: var(--ink);
        background: radial-gradient(900px 360px at 0% -10%, #edf7ff 0%, transparent 65%), var(--bg);
      }
      .topbar {
        display: flex;
        gap: 8px;
        align-items: center;
        justify-content: space-between;
        padding: 10px 14px;
        border-bottom: 1px solid var(--line);
        background: #fff;
        position: sticky;
        top: 0;
        z-index: 10;
      }
      .topbar .left, .topbar .right { display: flex; gap: 8px; align-items: center; }
      button, .btn {
        border: 1px solid var(--line);
        background: #fff;
        border-radius: 8px;
        padding: 8px 10px;
        cursor: pointer;
        color: var(--ink);
      }
      .btn-primary { background: var(--brand); color: #fff; border-color: var(--brand); }
      button:disabled { opacity: .55; cursor: not-allowed; }
      .layout {
        display: grid;
        grid-template-columns: 260px 1fr 340px;
        gap: 10px;
        padding: 10px;
        min-height: calc(100vh - 58px);
      }
      .panel {
        background: var(--panel);
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 10px;
      }
      .panel h3 {
        margin: 0 0 10px;
        font-size: 14px;
        color: var(--muted);
      }
      .slides {
        display: grid;
        gap: 6px;
        max-height: calc(100vh - 180px);
        overflow: auto;
      }
      .slide-item {
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 8px;
        background: #fff;
        cursor: pointer;
      }
      .slide-item.active {
        border-color: #60a5fa;
        background: #eff6ff;
      }
      .slide-item .title {
        font-size: 12px;
        font-weight: 700;
      }
      .slide-item .meta {
        font-size: 11px;
        color: var(--muted);
        margin-top: 2px;
      }
      .preview-wrap { height: calc(100vh - 120px); }
      iframe {
        width: 100%;
        height: 100%;
        border: 1px solid var(--line);
        border-radius: 8px;
        background: #fff;
      }
      .form-row { display: grid; gap: 6px; margin-bottom: 10px; }
      .form-row label { font-size: 12px; color: var(--muted); }
      input[type="text"], input[type="number"], select, textarea {
        width: 100%;
        border: 1px solid var(--line);
        border-radius: 8px;
        padding: 8px;
        font: inherit;
        background: #fff;
      }
      textarea { min-height: 100px; resize: vertical; }
      .stack { display: flex; gap: 6px; flex-wrap: wrap; }
      .stack > * { flex: 1 1 auto; min-width: 0; }
      .inline-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
      .inline-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px; }
      .hint { font-size: 12px; color: var(--muted); }
      .hint.warn { color: #92400e; }
      .radio-row { display: flex; gap: 12px; align-items: center; font-size: 12px; color: var(--muted); }
      .radio-row label { display: inline-flex; gap: 6px; align-items: center; }
      .section-box {
        margin-top: 10px;
        border-top: 1px dashed var(--line);
        padding-top: 10px;
      }
      .match-count {
        font-size: 12px;
        color: var(--muted);
        min-height: 18px;
      }
      .log {
        margin-top: 12px;
        border: 1px solid var(--line);
        border-radius: 10px;
        background: #f8fbff;
        padding: 8px;
      }
      .log h4 {
        margin: 0 0 6px;
        font-size: 12px;
        color: var(--muted);
      }
      .log ul {
        margin: 0;
        padding-left: 18px;
        max-height: 180px;
        overflow: auto;
        font-size: 12px;
      }
      @media (max-width: 1100px) {
        .layout { grid-template-columns: 1fr; }
        .preview-wrap { height: 56vh; }
      }
    </style>
  </head>
  <body>
    <header class="topbar">
      <div class="left">
        <strong>Step2-A Editor</strong>
        <span class="hint" id="statusText">No document loaded</span>
      </div>
      <div class="right">
        <input id="fileInput" type="file" accept=".html,text/html" />
        <button id="btnLoadStorage">Load Step1</button>
        <button id="btnUndo" disabled>Undo</button>
        <button id="btnRedo" disabled>Redo</button>
        <select id="exportProfile" aria-label="Export profile">
          <option value="web" selected>Web</option>
          <option value="pdf-a4">PDF-A4</option>
          <option value="executive">Executive</option>
        </select>
        <button id="btnDownload" class="btn-primary" disabled>Download Edited HTML</button>
      </div>
    </header>

    <main class="layout">
      <section class="panel">
        <h3>Slides</h3>
        <div class="stack" style="margin-bottom:8px;">
          <button id="btnMoveUp" disabled>Up</button>
          <button id="btnMoveDown" disabled>Down</button>
          <button id="btnDuplicate" disabled>Duplicate</button>
          <button id="btnDelete" disabled>Delete</button>
          <button id="btnToggleHide" disabled>Hide/Show</button>
        </div>
        <div id="slideList" class="slides"></div>
      </section>

      <section class="panel preview-wrap">
        <iframe id="preview" title="Step2-A preview"></iframe>
      </section>

      <section class="panel">
        <h3>Selected Slide</h3>
        <div class="form-row">
          <label for="titleInput">Title</label>
          <input id="titleInput" type="text" />
        </div>
        <div class="form-row">
          <label for="bodyInput">Body (first paragraph)</label>
          <textarea id="bodyInput"></textarea>
        </div>
        <div class="stack">
          <button id="btnApplyText" class="btn-primary" disabled>Apply Text</button>
          <button id="btnSyncFromFrame" disabled>Sync From Preview</button>
        </div>
        <div class="section-box">
          <h3>Style</h3>
          <div class="radio-row">
            <label><input type="radio" name="styleTarget" value="title" checked /> Title</label>
            <label><input type="radio" name="styleTarget" value="body" /> Body</label>
          </div>
          <div class="inline-2" style="margin-top:8px;">
            <div class="form-row" style="margin-bottom:0;">
              <label for="styleFontSize">Font size (px)</label>
              <input id="styleFontSize" type="number" min="16" max="64" step="1" />
            </div>
            <div class="form-row" style="margin-bottom:0;">
              <label for="styleFontWeight">Font weight</label>
              <select id="styleFontWeight">
                <option value="400">400</option>
                <option value="500">500</option>
                <option value="600">600</option>
                <option value="700">700</option>
                <option value="800">800</option>
              </select>
            </div>
          </div>
          <div class="inline-2" style="margin-top:6px;">
            <div class="form-row" style="margin-bottom:0;">
              <label for="styleTextAlign">Align</label>
              <select id="styleTextAlign">
                <option value="left">left</option>
                <option value="center">center</option>
                <option value="right">right</option>
              </select>
            </div>
            <div class="form-row" style="margin-bottom:0;">
              <label for="styleColorHex">Text color</label>
              <div class="inline-2">
                <input id="styleColor" type="color" value="#111111" />
                <input id="styleColorHex" type="text" value="#111111" />
              </div>
            </div>
          </div>
          <div class="stack" style="margin-top:8px;">
            <button id="btnApplyStyle" class="btn-primary" disabled>Apply Style</button>
            <button id="btnResetStyle" disabled>Reset Style</button>
          </div>
        </div>
        <div class="section-box">
          <h3>Replace</h3>
          <div class="form-row" style="margin-bottom:6px;">
            <label for="replaceFind">Find</label>
            <input id="replaceFind" type="text" />
          </div>
          <div class="form-row" style="margin-bottom:6px;">
            <label for="replaceWith">Replace</label>
            <input id="replaceWith" type="text" />
          </div>
          <div class="inline-2" style="margin-bottom:6px;">
            <label class="hint"><input id="replaceMatchCase" type="checkbox" /> Match case</label>
            <label class="hint"><input id="replaceWholeWord" type="checkbox" /> Whole word</label>
          </div>
          <div class="form-row" style="margin-bottom:6px;">
            <label for="replaceScope">Scope</label>
            <select id="replaceScope">
              <option value="current">Current slide</option>
              <option value="all">All slides</option>
            </select>
          </div>
          <p class="hint warn">Whole word uses English-style boundaries and may be imprecise for Korean text.</p>
          <div class="stack" style="margin-top:8px;">
            <button id="btnCountMatches" disabled>Count Matches</button>
            <button id="btnApplyReplace" class="btn-primary" disabled>Replace</button>
          </div>
          <div id="replaceCount" class="match-count">0 matches</div>
        </div>
        <p class="hint" style="margin-top:10px;">
          You can edit directly in preview and sync it here. Keyboard shortcuts: Ctrl+Z / Ctrl+Y.
        </p>
        <div class="log">
          <h4>Change Log</h4>
          <ul id="changeLog"></ul>
        </div>
      </section>
    </main>

    <script>
      const STORAGE_KEY = "STEP2A_HTML";
      const MAX_HISTORY = 80;
      const MAX_LOG = 120;

      const state = {
        doc: null,
        selected: 0,
        blobUrl: "",
        history: [],
        future: [],
        changeLog: [],
      };

      const els = {
        fileInput: document.getElementById("fileInput"),
        btnLoadStorage: document.getElementById("btnLoadStorage"),
        btnDownload: document.getElementById("btnDownload"),
        exportProfile: document.getElementById("exportProfile"),
        btnUndo: document.getElementById("btnUndo"),
        btnRedo: document.getElementById("btnRedo"),
        btnMoveUp: document.getElementById("btnMoveUp"),
        btnMoveDown: document.getElementById("btnMoveDown"),
        btnDuplicate: document.getElementById("btnDuplicate"),
        btnDelete: document.getElementById("btnDelete"),
        btnToggleHide: document.getElementById("btnToggleHide"),
        btnApplyText: document.getElementById("btnApplyText"),
        btnSyncFromFrame: document.getElementById("btnSyncFromFrame"),
        slideList: document.getElementById("slideList"),
        preview: document.getElementById("preview"),
        statusText: document.getElementById("statusText"),
        titleInput: document.getElementById("titleInput"),
        bodyInput: document.getElementById("bodyInput"),
        changeLog: document.getElementById("changeLog"),
        styleTarget: document.querySelectorAll('input[name="styleTarget"]'),
        styleFontSize: document.getElementById("styleFontSize"),
        styleFontWeight: document.getElementById("styleFontWeight"),
        styleTextAlign: document.getElementById("styleTextAlign"),
        styleColor: document.getElementById("styleColor"),
        styleColorHex: document.getElementById("styleColorHex"),
        btnApplyStyle: document.getElementById("btnApplyStyle"),
        btnResetStyle: document.getElementById("btnResetStyle"),
        replaceFind: document.getElementById("replaceFind"),
        replaceWith: document.getElementById("replaceWith"),
        replaceMatchCase: document.getElementById("replaceMatchCase"),
        replaceWholeWord: document.getElementById("replaceWholeWord"),
        replaceScope: document.getElementById("replaceScope"),
        btnCountMatches: document.getElementById("btnCountMatches"),
        btnApplyReplace: document.getElementById("btnApplyReplace"),
        replaceCount: document.getElementById("replaceCount"),
      };

      function parseHtml(html) {
        return new DOMParser().parseFromString(html, "text/html");
      }

      function getSlides(doc) {
        const primary = Array.from(doc.querySelectorAll("section.slide, .slide, [data-slide]"));
        if (primary.length) {
          return primary.filter((node) => !primary.some((other) => other !== node && other.contains(node)));
        }

        const sections = Array.from(doc.querySelectorAll("body > section, main > section, .slides > section"));
        if (sections.length) return sections;

        if (doc.body) {
          const bodyChildren = Array.from(doc.body.children).filter((el) => {
            const tag = el.tagName.toLowerCase();
            return tag !== "script" && tag !== "style";
          });
          if (bodyChildren.length) return bodyChildren;
        }

        return [];
      }

      function selectedSlide() {
        const slides = getSlides(state.doc);
        if (!slides.length) return null;
        state.selected = Math.max(0, Math.min(state.selected, slides.length - 1));
        return slides[state.selected] || null;
      }

      function textOf(el) {
        return (el ? el.textContent : "").replace(/\s+/g, " ").trim();
      }

      function styleTargetMode() {
        const checked = Array.from(els.styleTarget).find((el) => el.checked);
        return checked ? checked.value : "title";
      }

      function targetSelectors(mode) {
        if (mode === "title") return ['[data-step2-role="title"]', "h1,h2,h3,h4"];
        return ['[data-step2-role="body"]', "p,li,figcaption,blockquote"];
      }

      function findTargetElement(slide, mode) {
        const selectors = targetSelectors(mode);
        return slide.querySelector(selectors[0]) || slide.querySelector(selectors[1]);
      }

      function getOrCreateTargetElement(slide, mode) {
        let target = findTargetElement(slide, mode);
        if (target) return target;
        if (mode === "title") {
          target = state.doc.createElement("h2");
          target.setAttribute("data-step2-role", "title");
          slide.prepend(target);
          return target;
        }
        target = state.doc.createElement("p");
        target.setAttribute("data-step2-role", "body");
        slide.appendChild(target);
        return target;
      }

      function clampSize(n) {
        return Math.max(16, Math.min(64, Number(n) || 16));
      }

      function normalizeHexColor(value) {
        const raw = String(value || "").trim();
        const hex = raw.startsWith("#") ? raw : `#${raw}`;
        if (/^#[0-9a-fA-F]{6}$/.test(hex)) return hex.toLowerCase();
        if (/^#[0-9a-fA-F]{3}$/.test(hex)) {
          const r = hex[1], g = hex[2], b = hex[3];
          return `#${r}${r}${g}${g}${b}${b}`.toLowerCase();
        }
        return "#111111";
      }

      function rgbToHex(color) {
        const m = String(color || "").match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
        if (!m) return normalizeHexColor(color || "#111111");
        const toHex = (n) => Number(n).toString(16).padStart(2, "0");
        return `#${toHex(m[1])}${toHex(m[2])}${toHex(m[3])}`;
      }

      function slideTitle(slide, idx) {
        const heading = slide.querySelector("h1,h2,h3,h4");
        const t = textOf(heading) || textOf(slide).slice(0, 48) || `Slide ${idx + 1}`;
        return t.slice(0, 64);
      }

      function docToHtml(doc) {
        return "<!doctype html>\n" + doc.documentElement.outerHTML;
      }

      function cleanBeforeExport(doc) {
        doc.querySelectorAll("[data-step2-index]").forEach((el) => {
          el.removeAttribute("data-step2-index");
          el.removeAttribute("contenteditable");
          el.style.outline = "";
          el.style.outlineOffset = "";
        });
      }

      function injectProfileCss(doc, profile) {
        const old = doc.getElementById("step2-export-profile");
        if (old) old.remove();
        if (profile === "web") return;

        const style = doc.createElement("style");
        style.id = "step2-export-profile";
        if (profile === "pdf-a4") {
          style.textContent = `
            @page { size: A4; margin: 12mm; }
            section.slide, .slide { page-break-after: always; break-after: page; }
            .nav-ui, .navigation, .slide-number, #controls, nav { display: none !important; }
            [style*="position: fixed"] { position: absolute !important; }
            html, body { overflow: visible !important; }
          `;
        } else if (profile === "executive") {
          style.textContent = `
            body { font-size: calc(1em + 1px) !important; line-height: 1.42 !important; color: #111827 !important; }
            p, li { line-height: 1.45 !important; }
            h1, h2, h3, h4 { color: #0f172a !important; }
          `;
        }
        doc.head.appendChild(style);
      }

      function snapshot() {
        if (!state.doc) return null;
        return {
          html: docToHtml(state.doc),
          selected: state.selected,
        };
      }

      function restoreSnapshot(s) {
        if (!s || !s.html) return;
        state.doc = parseHtml(s.html);
        state.selected = Number.isFinite(Number(s.selected)) ? Number(s.selected) : 0;
        render();
      }

      function pushChange(action) {
        const ts = new Date();
        const stamp = `${String(ts.getHours()).padStart(2, "0")}:${String(ts.getMinutes()).padStart(2, "0")}:${String(ts.getSeconds()).padStart(2, "0")}`;
        state.changeLog.unshift({ stamp, action });
        if (state.changeLog.length > MAX_LOG) state.changeLog.pop();
      }

      function commit(action) {
        const s = snapshot();
        if (!s) return;
        state.history.push(s);
        if (state.history.length > MAX_HISTORY) state.history.shift();
        state.future = [];
        pushChange(action);
        renderChangeLog();
        refreshToolbar();
      }

      function renderChangeLog() {
        els.changeLog.innerHTML = "";
        state.changeLog.forEach((item) => {
          const li = document.createElement("li");
          li.textContent = `[${item.stamp}] ${item.action}`;
          els.changeLog.appendChild(li);
        });
      }

      function annotateSlides() {
        const slides = getSlides(state.doc);
        slides.forEach((slide, idx) => {
          slide.setAttribute("data-step2-index", String(idx));
          slide.removeAttribute("contenteditable");
          if (idx === state.selected) {
            slide.style.outline = "3px solid #60a5fa";
            slide.style.outlineOffset = "-3px";
          } else {
            slide.style.outline = "";
            slide.style.outlineOffset = "";
          }
        });
      }

      function syncInputs() {
        const slide = selectedSlide();
        if (!slide) {
          els.titleInput.value = "";
          els.bodyInput.value = "";
          syncStyleInputs();
          return;
        }
        const heading = findTargetElement(slide, "title");
        const paragraph = findTargetElement(slide, "body");
        els.titleInput.value = textOf(heading);
        els.bodyInput.value = textOf(paragraph);
        syncStyleInputs();
      }

      function readTargetStyleFromPreview(mode) {
        const frameDoc = els.preview.contentDocument;
        if (!frameDoc) return null;
        const rootSlide = frameDoc.querySelector(".step2-preview-root > *");
        if (!rootSlide) return null;
        const target = findTargetElement(rootSlide, mode);
        if (!target) return null;
        const cs = frameDoc.defaultView && frameDoc.defaultView.getComputedStyle
          ? frameDoc.defaultView.getComputedStyle(target)
          : null;
        if (!cs) return null;
        return {
          fontSize: parseInt(cs.fontSize, 10) || 16,
          fontWeight: String(cs.fontWeight || "400"),
          textAlign: String(cs.textAlign || "left"),
          color: rgbToHex(cs.color || "#111111"),
        };
      }

      function syncStyleInputs() {
        const slide = selectedSlide();
        if (!slide) {
          els.styleFontSize.value = "24";
          els.styleFontWeight.value = "700";
          els.styleTextAlign.value = "left";
          els.styleColor.value = "#111111";
          els.styleColorHex.value = "#111111";
          return;
        }
        const mode = styleTargetMode();
        const target = findTargetElement(slide, mode);
        const fromPreview = readTargetStyleFromPreview(mode);
        const inline = target ? target.style : null;

        const fontSize = inline && inline.fontSize ? parseInt(inline.fontSize, 10) : (fromPreview ? fromPreview.fontSize : 24);
        const fontWeight = inline && inline.fontWeight ? inline.fontWeight : (fromPreview ? fromPreview.fontWeight : "700");
        const textAlign = inline && inline.textAlign ? inline.textAlign : (fromPreview ? fromPreview.textAlign : "left");
        const color = inline && inline.color ? rgbToHex(inline.color) : (fromPreview ? fromPreview.color : "#111111");

        els.styleFontSize.value = String(clampSize(fontSize));
        els.styleFontWeight.value = ["400", "500", "600", "700", "800"].includes(String(fontWeight)) ? String(fontWeight) : "700";
        els.styleTextAlign.value = ["left", "center", "right"].includes(String(textAlign)) ? String(textAlign) : "left";
        els.styleColor.value = normalizeHexColor(color);
        els.styleColorHex.value = normalizeHexColor(color);
      }

      function refreshToolbar() {
        const hasDoc = Boolean(state.doc);
        const slides = hasDoc ? getSlides(state.doc) : [];
        const hasSlides = slides.length > 0;

        els.btnDownload.disabled = !hasDoc;
        els.btnUndo.disabled = state.history.length === 0;
        els.btnRedo.disabled = state.future.length === 0;

        els.btnMoveUp.disabled = !hasSlides || state.selected <= 0;
        els.btnMoveDown.disabled = !hasSlides || state.selected >= slides.length - 1;
        els.btnDuplicate.disabled = !hasSlides;
        els.btnDelete.disabled = !hasSlides || slides.length <= 1;
        els.btnToggleHide.disabled = !hasSlides;
        els.btnApplyText.disabled = !hasSlides;
        els.btnSyncFromFrame.disabled = !hasSlides;
        els.btnApplyStyle.disabled = !hasSlides;
        els.btnResetStyle.disabled = !hasSlides;
        els.btnCountMatches.disabled = !hasSlides;
        els.btnApplyReplace.disabled = !hasSlides;
      }

      function render() {
        if (!state.doc) {
          els.preview.srcdoc = "";
          els.slideList.innerHTML = "";
          els.statusText.textContent = "No document loaded";
          refreshToolbar();
          return;
        }

        annotateSlides();
        const html = buildEditorPreviewHtml();
        els.preview.onload = () => syncStyleInputs();
        els.preview.srcdoc = html;
        renderSlideList();
        syncInputs();
        const slides = getSlides(state.doc);
        els.statusText.textContent = `Loaded - ${slides.length} slides`;
        refreshToolbar();
      }

      function buildEditorPreviewHtml() {
        const clone = state.doc.cloneNode(true);
        const slides = getSlides(clone);
        if (!slides.length) return docToHtml(clone);

        const selected = Math.max(0, Math.min(state.selected, slides.length - 1));
        const selectedSlide = slides[selected].cloneNode(true);

        const previewDoc = document.implementation.createHTMLDocument("Step2 Preview");
        previewDoc.documentElement.lang = "en";

        clone.querySelectorAll("head style, head link[rel='stylesheet']").forEach((node) => {
          previewDoc.head.appendChild(node.cloneNode(true));
        });

        const style = previewDoc.createElement("style");
        style.textContent = `
          html, body {
            margin: 0 !important;
            padding: 0 !important;
            background: #ffffff !important;
            overflow: auto !important;
          }
          body::before, body::after { display: none !important; content: none !important; }
          .step2-preview-root, .step2-preview-root * {
            user-select: text !important;
            -webkit-user-select: text !important;
            pointer-events: auto !important;
            caret-color: auto !important;
          }
          .step2-preview-root { cursor: text !important; }
          .step2-preview-root {
            min-height: 100vh;
            padding: 12px;
          }
          .step2-preview-root section.slide,
          .step2-preview-root .slide {
            display: block !important;
            opacity: 1 !important;
            visibility: visible !important;
            transform: none !important;
            position: relative !important;
            inset: auto !important;
            filter: none !important;
          }
          .step2-preview-root * {
            animation: none !important;
            transition: none !important;
          }
          .step2-preview-root [style*="position: fixed"] {
            position: absolute !important;
          }
        `;
        previewDoc.head.appendChild(style);

        const srcBody = clone.body;
        if (srcBody) {
          previewDoc.body.className = srcBody.className || "";
          if (srcBody.id) previewDoc.body.id = srcBody.id;
        }

        const root = previewDoc.createElement("div");
        root.className = "step2-preview-root";
        root.setAttribute("contenteditable", "true");
        root.setAttribute("spellcheck", "false");
        root.setAttribute("tabindex", "0");
        root.appendChild(selectedSlide);
        previewDoc.body.innerHTML = "";
        previewDoc.body.appendChild(root);

        return docToHtml(previewDoc);
      }

      function renderSlideList() {
        els.slideList.innerHTML = "";
        const slides = getSlides(state.doc);
        slides.forEach((slide, idx) => {
          const item = document.createElement("div");
          item.className = "slide-item" + (idx === state.selected ? " active" : "");
          const hidden = slide.getAttribute("data-step2-hidden") === "1";
          item.innerHTML = `<div class="title">${idx + 1}. ${slideTitle(slide, idx)}</div><div class="meta">${hidden ? "Hidden" : "Visible"}</div>`;
          item.addEventListener("click", () => {
            state.selected = idx;
            render();
          });
          els.slideList.appendChild(item);
        });
      }

      function loadHtml(html) {
        state.doc = parseHtml(html);
        state.selected = 0;
        state.history = [];
        state.future = [];
        state.changeLog = [];
        pushChange("Loaded document");
        renderChangeLog();
        render();
      }

      function moveSelected(offset) {
        const slides = getSlides(state.doc);
        const from = state.selected;
        const to = from + offset;
        if (to < 0 || to >= slides.length) return;
        commit(offset > 0 ? "Move slide down" : "Move slide up");
        const parent = slides[from].parentNode;
        const node = slides[from];
        if (offset > 0) parent.insertBefore(node, slides[to].nextSibling);
        else parent.insertBefore(node, slides[to]);
        state.selected = to;
        render();
      }

      function duplicateSelected() {
        const slide = selectedSlide();
        if (!slide) return;
        commit("Duplicate slide");
        const clone = slide.cloneNode(true);
        slide.parentNode.insertBefore(clone, slide.nextSibling);
        state.selected += 1;
        render();
      }

      function deleteSelected() {
        const slides = getSlides(state.doc);
        if (slides.length <= 1) return;
        const slide = selectedSlide();
        if (!slide) return;
        commit("Delete slide");
        slide.remove();
        state.selected = Math.max(0, state.selected - 1);
        render();
      }

      function toggleHideSelected() {
        const slide = selectedSlide();
        if (!slide) return;
        const hidden = slide.getAttribute("data-step2-hidden") === "1";
        commit(hidden ? "Show slide" : "Hide slide");
        if (hidden) {
          slide.setAttribute("data-step2-hidden", "0");
          slide.style.display = "";
        } else {
          slide.setAttribute("data-step2-hidden", "1");
          slide.style.display = "none";
        }
        render();
      }

      function applyText() {
        const slide = selectedSlide();
        if (!slide) return;
        commit("Apply text edit");
        const heading = getOrCreateTargetElement(slide, "title");
        if (els.titleInput.value.trim()) {
          heading.textContent = els.titleInput.value.trim();
        }

        const paragraph = getOrCreateTargetElement(slide, "body");
        if (els.bodyInput.value.trim()) paragraph.textContent = els.bodyInput.value.trim();
        render();
      }

      function applyStyleControls() {
        const slide = selectedSlide();
        if (!slide) return;
        const mode = styleTargetMode();
        const target = getOrCreateTargetElement(slide, mode);
        commit(`Apply style: ${mode}`);

        target.style.fontSize = `${clampSize(els.styleFontSize.value)}px`;
        target.style.fontWeight = els.styleFontWeight.value || "700";
        target.style.textAlign = els.styleTextAlign.value || "left";
        const hex = normalizeHexColor(els.styleColorHex.value || els.styleColor.value);
        target.style.color = hex;
        els.styleColor.value = hex;
        els.styleColorHex.value = hex;
        render();
      }

      function resetStyleControls() {
        const slide = selectedSlide();
        if (!slide) return;
        const mode = styleTargetMode();
        const target = findTargetElement(slide, mode);
        if (!target) return;
        commit(`Reset style: ${mode}`);
        target.style.removeProperty("font-size");
        target.style.removeProperty("font-weight");
        target.style.removeProperty("text-align");
        target.style.removeProperty("color");
        if (!target.getAttribute("style")) target.removeAttribute("style");
        render();
      }

      function escapeRegex(s) {
        return String(s).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }

      function replaceRegex() {
        const find = els.replaceFind.value || "";
        if (!find) return null;
        const escaped = escapeRegex(find);
        const source = els.replaceWholeWord.checked ? `\\b${escaped}\\b` : escaped;
        const flags = `g${els.replaceMatchCase.checked ? "" : "i"}`;
        return new RegExp(source, flags);
      }

      function replaceRoots() {
        if (els.replaceScope.value === "current") {
          const slide = selectedSlide();
          return slide ? [slide] : [];
        }
        return getSlides(state.doc);
      }

      function isReplaceNodeAllowed(node) {
        const parent = node.parentElement;
        if (!parent) return false;
        const tag = parent.tagName.toUpperCase();
        if (["SCRIPT", "STYLE", "NOSCRIPT", "TEXTAREA", "INPUT", "CODE", "PRE"].includes(tag)) return false;
        if (parent.closest(".nav-ui, .navigation, .slide-number, #controls")) return false;
        return true;
      }

      function walkTextNodes(root, fn) {
        const walker = root.ownerDocument.createTreeWalker(root, NodeFilter.SHOW_TEXT);
        let node = walker.nextNode();
        while (node) {
          if (isReplaceNodeAllowed(node)) fn(node);
          node = walker.nextNode();
        }
      }

      function countReplaceMatches() {
        if (!state.doc) return 0;
        const re = replaceRegex();
        if (!re) return 0;
        let count = 0;
        replaceRoots().forEach((root) => {
          walkTextNodes(root, (node) => {
            re.lastIndex = 0;
            const matches = node.nodeValue.match(re);
            if (matches) count += matches.length;
          });
        });
        return count;
      }

      function previewReplaceMatches() {
        const count = countReplaceMatches();
        els.replaceCount.textContent = `${count} matches`;
      }

      function applyReplace() {
        if (!state.doc) return;
        const re = replaceRegex();
        if (!re) {
          els.replaceCount.textContent = "0 matches";
          return;
        }
        const replacement = els.replaceWith.value || "";
        const roots = replaceRoots();
        let changed = 0;

        roots.forEach((root) => {
          walkTextNodes(root, (node) => {
            re.lastIndex = 0;
            const before = node.nodeValue;
            const matches = before.match(re);
            if (!matches || !matches.length) return;
            changed += matches.length;
          });
        });

        els.replaceCount.textContent = `${changed} matches`;
        if (!changed) return;

        const scope = els.replaceScope.value;
        commit(`Replace: ${changed} changes (scope=${scope})`);
        roots.forEach((root) => {
          walkTextNodes(root, (node) => {
            re.lastIndex = 0;
            node.nodeValue = node.nodeValue.replace(re, replacement);
          });
        });
        render();
      }

      function syncFromPreview() {
        const frameDoc = els.preview.contentDocument;
        if (!frameDoc) return;
        const source =
          frameDoc.querySelector(".step2-preview-root > *") ||
          frameDoc.querySelector(`[data-step2-index="${state.selected}"]`) ||
          frameDoc.querySelector("section.slide, .slide, [data-slide], .step2-preview-root > *");
        const target = selectedSlide();
        if (!source || !target) return;
        commit("Sync selected slide from preview");
        target.outerHTML = source.outerHTML;
        render();
      }

      function undo() {
        if (!state.history.length || !state.doc) return;
        const current = snapshot();
        const prev = state.history.pop();
        if (current) {
          state.future.push(current);
          if (state.future.length > MAX_HISTORY) state.future.shift();
        }
        pushChange("Undo");
        renderChangeLog();
        restoreSnapshot(prev);
      }

      function redo() {
        if (!state.future.length || !state.doc) return;
        const current = snapshot();
        const next = state.future.pop();
        if (current) {
          state.history.push(current);
          if (state.history.length > MAX_HISTORY) state.history.shift();
        }
        pushChange("Redo");
        renderChangeLog();
        restoreSnapshot(next);
      }

      function downloadEdited() {
        if (!state.doc) return;
        const clone = state.doc.cloneNode(true);
        cleanBeforeExport(clone);
        injectProfileCss(clone, els.exportProfile.value || "web");
        const html = docToHtml(clone);
        const blob = new Blob([html], { type: "text/html;charset=utf-8" });
        if (state.blobUrl) URL.revokeObjectURL(state.blobUrl);
        state.blobUrl = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = state.blobUrl;
        a.download = "step2a-edited.html";
        a.click();
      }

      function loadFromStorage() {
        const html = localStorage.getItem(STORAGE_KEY) || "";
        if (!html.trim()) {
          alert("Step1 result not found. Generate Step1 first.");
          return;
        }
        loadHtml(html);
      }

      els.btnLoadStorage.addEventListener("click", loadFromStorage);
      els.btnDownload.addEventListener("click", downloadEdited);
      els.btnUndo.addEventListener("click", undo);
      els.btnRedo.addEventListener("click", redo);
      els.btnMoveUp.addEventListener("click", () => moveSelected(-1));
      els.btnMoveDown.addEventListener("click", () => moveSelected(1));
      els.btnDuplicate.addEventListener("click", duplicateSelected);
      els.btnDelete.addEventListener("click", deleteSelected);
      els.btnToggleHide.addEventListener("click", toggleHideSelected);
      els.btnApplyText.addEventListener("click", applyText);
      els.btnApplyStyle.addEventListener("click", applyStyleControls);
      els.btnResetStyle.addEventListener("click", resetStyleControls);
      els.btnCountMatches.addEventListener("click", previewReplaceMatches);
      els.btnApplyReplace.addEventListener("click", applyReplace);
      els.btnSyncFromFrame.addEventListener("click", syncFromPreview);
      els.styleTarget.forEach((radio) => radio.addEventListener("change", syncStyleInputs));
      els.styleColor.addEventListener("input", () => {
        els.styleColorHex.value = normalizeHexColor(els.styleColor.value);
      });
      els.styleColorHex.addEventListener("input", () => {
        const hex = normalizeHexColor(els.styleColorHex.value);
        els.styleColor.value = hex;
      });
      [els.replaceFind, els.replaceWith, els.replaceMatchCase, els.replaceWholeWord, els.replaceScope].forEach((el) => {
        el.addEventListener("input", previewReplaceMatches);
        el.addEventListener("change", previewReplaceMatches);
      });

      els.fileInput.addEventListener("change", async (e) => {
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        const text = await file.text();
        loadHtml(text);
      });

      document.addEventListener("keydown", (e) => {
        if (e.ctrlKey && !e.shiftKey && (e.key === "z" || e.key === "Z")) {
          e.preventDefault();
          undo();
        }
        if ((e.ctrlKey && (e.key === "y" || e.key === "Y")) || (e.ctrlKey && e.shiftKey && (e.key === "z" || e.key === "Z"))) {
          e.preventDefault();
          redo();
        }
      });

      window.addEventListener("beforeunload", () => {
        if (state.blobUrl) URL.revokeObjectURL(state.blobUrl);
      });

      try {
        const html = localStorage.getItem(STORAGE_KEY) || "";
        if (html.trim()) loadHtml(html);
        else render();
      } catch (_) {
        render();
      }
    </script>
  </body>
</html>
